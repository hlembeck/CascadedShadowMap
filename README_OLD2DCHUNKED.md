# CascadedShadowMap Readme

## Virtual Tiled Terrain, New:

### Introduction:
This terrain renderer uses a virtual texture, of format `float4`, to stream in new 'chunks' as necessary, where the chunks are generated on the GPU with a seperate CPU thread. Since there is no performance impact to doing so, the virtual texture is created with maximum size, which is $2^{14}\times2^{14}$. We reserve 8MB, which is $2^{23}/2^{16}=2^{7}$ tiles, to fill the view frustum with coarse terrain. Imposing this requirement ensures enough terrain can always be rendered. However, this requirement also imposes a minimum worldspace span of coase tiles, since if the frustum is too large, 8MB may not cover with narrower woldspace tiling.

To help alleviate this, we find the maximum number of coarse tiles necessary to fill the frustum. This is not trivial, as rotation of the frustum can increase the number of tiles required.

### Frustum Covering:

~~First, let's assume the frustum is actually the cap of a pyramid, and reduce to the 2D case, in which we're looking at a triangle. We can take the triangle to be of width equal to the diagonal of the quad bounding the cap of the pyramid, and whose side lengths are equal to the side lengths of the pyramid. We can assume the triangle is isosceles, with its right side pointing in direction $(\cos(\theta),\sin(\theta))$ and its tip at point $(x,y)\in\[0,1)^{2}$. The problem of finding integral lattice points in the triangle can be solved with Pick's theoem, assuming that we align the points to the integral lattice.~~

For now, we set the coarse terrain tiles to span the smallest rectangle containing the hemisphere generated by rotating the frustum. With $128$ tiles to work with, we need $64$ tiles to cover half this rectangle, which is then a $8\times 8$ grid of tiles. If $L$ is the length of the frustum and $\log_2(L/63)=k$, then take tiles of width $63\cdot 2^{\lceil k\rceil-3}$. Then the $8\times 8$ grid spans the half rectangle, and choosing one less power of two for the size would not cover the rectangle.






### Introduction:
The tiled terrain implemented in this repository uses a virtual texture to store the heightmap data that is to be rendered on screen. The heightfield format is a `float4`, where the first coordinate is the height at the point, and the other three coordinates are the normal at the point. With this format, tiles in the virtual texture are of size $64\times 64$, so for simplicity we choose a resolution of $63\times 63$ for the heightmap data.

### Definitions:
- A **Chunk** is a 

Suppose the camera is centered at the point $(x,0,z)$, where 0 is the "sea level" of our terrain. To make sure that all terrain in the frustum is visible, and to allow fast rotation without updating the virtual texture, we require that a sufficiently large grid of tiles is resident on the GPU. This grid is aligned to 62x62 worldspace tiles, and is centered about the camera (as best as possible).

A few notes regarding the desire to have a camera-centered grid.
- As the view frustum grows, the necessary number of tiles increases quadratically. Thus, if we want to maintain the assertion that we always have the entire grid renderable (that is, at least the lowest level tile is resident, for each chunk), we are forced to increase the tree depth as frustum size increases. Ignoring floating point precision issues, increasing tree depth will work for all frustum sizes (since the frustum length is itself bound by floats).
- It may also be worthwhile to forego the cented grid condition, and instead rely on the GPU to quickly render lowest-level terrain as the camera rotates, as is done when the camera moves. 

These initial tiles form the highest spatial extent terrain tiles in the terrain. We define the following data structures:

```
struct TileParams {
    XMMATRIX worldMatrix;
    XMUINT2 texCoords;
};

struct TileInformation {
    BoundingBox bounds;
    TileParams tileParams;
    INT isResident;
};
```
 - `struct TileParams` Tile parameters to be copied into a constant buffer for use in shaders.
    - `XMMATRIX worldMatrix` World matrix used to map [0,62]x[0,62] in worldspace to the correct bounds for the tile. In the vertex shader of the screen render stage, it is applied to the world position of a vertex after it has been scaled to the correct tile size (each level in the tree rooted at a max-spanning tile is half the span of the previous level).
    - `XMUINT2 texCoords` Texture coordinates, in texels, of the start of the tile. Since the loading of the texture is done manually at this time, UV coordinates are not used; we index directly into the resource.
 - `BoundingBox bounds` Spatial bounds of the terrain tile. Used to test for intersection with view frustum, using `BoundingBox::Intersects(BoundingFrustum)`.
 - `INT isResident` Integer value in $\{0,1\}$ that determines whether the tile is resident on the GPU. A value of $0$ is not resident, while a value of $1$ indicates that the tile is resident. INT is used instead of BOOL to ensure that the TRUE value is 1.
 
 `TileInformation` instances are members of the following class:
 
 ```
 class Tile {
    TileInformation m_tileInfo;
    Tile m_children[4];
 public:
    Tile();
    Tile(TileInformation);
  
    BOOL IsVisible(BoundingFrustum, XMMATRIX);
    BOOL NeedsUpdate(BoundingFrustum, XMMATRIX);
    XMMATRIX Create(float x, float y, UINT level, XMUINT2 texCoords);
    void Create(float x, float y);
 };
 ```
 
 

