#pragma once
#include "DXBase.h"
#include "TerrainHeightmap.h"

struct TileParams {
	XMMATRIX worldMatrix;
	XMUINT2 texCoords;
};

struct TileInformation {
	BoundingBox bounds;
	TileParams tileParams;
	INT isResident;
};

class Tile {
	TileInformation m_tileInfo;
public:
	Tile();
	Tile(TileInformation tileInfo);
	void SetTexCoords(XMUINT2 coords, INT isResident);
	BOOL IsVisible(BoundingFrustum frustum, XMMATRIX viewMatrix);
	BOOL NeedsUpdate(BoundingFrustum frustum, XMMATRIX viewMatrix);
	//(x,y) are coordinates of the bottom left of the tile, so that the tile spans (x,y) to (x+62*2^(MAXLEVELS-level-1),y+62*2^(MAXLEVELS-level-1))
	XMMATRIX Create(float x, float y, XMUINT2 texCoords, INT isRresident);
	//Create tile from the bottom-left corner (x,y), and worldspace width of the tile.
	void Create(float x, float y, float width);
	TileParams GetTileParams();
	XMFLOAT4 GetCircumscribedSphere();
};

class ImprovedChunk {
	BoundingBox m_bounds; //World-space bounds of the chunk.
public:
	void Create(float x, float y);
};

/*
Chunks of high resolution (2^NTERRAINLEVELS*(62,62)) are generated by the HeightmapGen class in a seperate thread; unless NTERRAINLEVELS is large, this can be generated in one pass by HeightmapGen. A tile at level i (i=0,...,NTERRAINLEVELS-1) loads this texture at a step of 2^(NTERRAINLEVELS-i); thus tiles of consecutive levels have steps that differ by a factor of 2. These tiles form a quadtree which can be traversed to determine which tiles to render. The geometrical error from the generated terrain is computed for each level in the ImprovedChunk class
*/
class ImprovedTerrain63 :
	public virtual DXBase,
	public virtual HeightmapGen
{
	//Needed to map tiles for virtual texturing.
	ComPtr<ID3D12CommandAllocator> m_commandAllocator;
	ComPtr<ID3D12GraphicsCommandList> m_commandList;
	ComPtr<ID3D12Fence> m_fence;
	HANDLE m_fenceEvent;

	ComPtr<ID3D12Resource> m_vertexBuffer;
	D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;

	//Testing virtual texture
	ComPtr<ID3D12Resource> m_virtualTexture;
	D3D12_GPU_DESCRIPTOR_HANDLE m_srvHandle; //SRV for virtual texture, used in RenderChunk
	//Heap for virtual texture
	ComPtr<ID3D12Heap> m_heap;

	//Quadtree forest on CPU to be traversed each upon camera update (change in position or direction)
	Tile** m_roots;
	UINT m_nRoots;
	//Testing storing geometric error as per level, for simplicity.
	float m_geomErrors[NTERRAINLEVELS];

	//Constant buffer for the world matrices and UV coordinate starts for tiles.
	ComPtr<ID3D12Resource> m_constantBuffer;
	D3D12_GPU_DESCRIPTOR_HANDLE m_cbvHandle;


	void CreateVertexTexture();
	void CreateVirtualTexture();
	void CreateCommandList();
	void WaitForList();

	//Testing
	XMMATRIX* CreateRoots(CameraView view);
	void CreateConstantBuffer();
	XMMATRIX CreateTileTree(UINT rootIndex, float x, float y, XMUINT2 texCoords);
	//tanFOVH = tan(fovH/2) = tan(0.5f*view.m_fovY)*view.m_aspectRatio
	float GetScreenError(UINT rootIndex, UINT level, TerrainLODViewParams viewParams);
	//Fills vector with all necessary tiles in a chunk(root) without overflowing cbuffer space.
	void GetChunkTileParams(std::vector<TileParams>& tileParams, Tile* pTiles, UINT maxSize, TerrainLODViewParams viewParams);
public:
	ImprovedTerrain63();
	~ImprovedTerrain63();
	void Init(CameraView view);

	//Tiles
	void RenderTiles(TerrainLODViewParams viewParams, ID3D12GraphicsCommandList* commandList);

	void UpdateRoots(ID3D12GraphicsCommandList* commandList, BoundingFrustum frustum, XMMATRIX viewMatrix);
};