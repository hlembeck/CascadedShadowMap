#pragma once
#include "DXBase.h"
#include "TerrainHeightmap.h"

struct TileParams {
	XMMATRIX worldMatrix;
	XMUINT2 texCoords;
};

class Tile {
	BoundingBox m_bounds;
	XMMATRIX m_worldMatrix; //Map from [0,63]x[0,63] -> world coordinates
	XMUINT2 m_texCoords;
	INT m_isResident;
public:
	Tile();
	Tile(BoundingBox bounds, XMMATRIX worldMatrix, XMUINT2 texCoords, INT isResident);
	void SetTexCoords(XMUINT2 coords, INT isResident);
	BOOL IsVisible(BoundingFrustum frustum, XMMATRIX viewMatrix);
	BOOL NeedsUpdate(BoundingFrustum frustum, XMMATRIX viewMatrix);
	//(x,y) are coordinates of the bottom left of the tile, so that the tile spans (x,y) to (x+62*2^(MAXLEVELS-level-1),y+62*2^(MAXLEVELS-level-1))
	XMMATRIX Create(float x, float y, UINT level, XMUINT2 texCoords);
	TileParams GetTileParams();
};

class ImprovedChunk {
	BoundingBox m_bounds; //World-space bounds of the chunk.
public:
	void Create(float x, float y);
};

/*
Chunks of high resolution (2^NTERRAINLEVELS*(62,62)) are generated by the HeightmapGen class in a seperate thread; unless NTERRAINLEVELS is large, this can be generated in one pass by HeightmapGen. A tile at level i (i=0,...,NTERRAINLEVELS-1) loads this texture at a step of 2^(NTERRAINLEVELS-i); thus tiles of consecutive levels have steps that differ by a factor of 2. These tiles form a quadtree which can be traversed to determine which tiles to render. The geometrical error from the generated terrain is computed for each level in the ImprovedChunk class
*/
class ImprovedTerrain63 :
	public virtual DXBase,
	public virtual HeightmapGen
{
	//Needed to map tiles for virtual texturing.
	ComPtr<ID3D12CommandAllocator> m_commandAllocator;
	ComPtr<ID3D12GraphicsCommandList> m_commandList;
	ComPtr<ID3D12Fence> m_fence;
	HANDLE m_fenceEvent;

	ComPtr<ID3D12Resource> m_vertexBuffer;
	D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;
	ImprovedChunk m_chunk; //Testing with single chunk

	//Testing virtual texture
	ComPtr<ID3D12Resource> m_virtualTexture;
	D3D12_GPU_DESCRIPTOR_HANDLE m_srvHandle; //SRV for virtual texture, used in RenderChunk
	//Heap for virtual texture
	ComPtr<ID3D12Heap> m_heap;

	//Quadtree forest on CPU to be traversed each upon camera update (change in position or direction)
	Tile* m_roots;
	UINT m_nRoots;

	//Test
	UINT frameIndex;

	//Constant buffer for the world matrices and UV coordinate starts for tiles.
	ComPtr<ID3D12Resource> m_constantBuffer;
	D3D12_GPU_DESCRIPTOR_HANDLE m_cbvHandle;

	void CreateVertexTexture();
	void CreateVirtualTexture();
	void CreateCommandList();
	void WaitForList();

	//Testing
	void CreateChunk();
	void CreateRoots(CameraView view);
	void CreateConstantBuffer();
public:
	ImprovedTerrain63();
	~ImprovedTerrain63();
	void Init(CameraView view);
	void RenderChunk(ID3D12GraphicsCommandList* commandList);

	//Tiles
	void RenderTiles(BoundingFrustum frustum, XMMATRIX viewMatrix, ID3D12GraphicsCommandList* commandList);

	void UpdateRoots(ID3D12GraphicsCommandList* commandList, BoundingFrustum frustum, XMMATRIX viewMatrix);
};